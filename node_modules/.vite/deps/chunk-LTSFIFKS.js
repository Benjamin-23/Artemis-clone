import {
  __export,
  vue_runtime_esm_bundler_exports
} from "./chunk-7X7NEOA6.js";

// node_modules/@progress/kendo-vue-popup/node_modules/@progress/kendo-vue-animation/dist/es/util.js
var outerHeight = function(element) {
  if (!element) {
    return 0;
  }
  var wnd = element.ownerDocument.defaultView;
  var computedStyles = wnd.getComputedStyle(element);
  var marginTop = parseFloat(computedStyles.marginTop);
  var marginBottom = parseFloat(computedStyles.marginBottom);
  return element.offsetHeight + marginTop + marginBottom;
};
var outerWidth = function(element) {
  if (!element) {
    return 0;
  }
  var wnd = element.ownerDocument.defaultView;
  var computedStyles = wnd.getComputedStyle(element);
  var marginLeft = parseFloat(computedStyles.marginLeft);
  var marginRight = parseFloat(computedStyles.marginRight);
  return element.offsetWidth + marginLeft + marginRight;
};
var styles = {
  "animation-container": "k-animation-container",
  "animation-container-relative": "k-animation-container-relative",
  "animation-container-fixed": "k-animation-container-fixed",
  "push-right-enter": "k-push-right-enter",
  "push-right-appear": "k-push-right-appear",
  "push-right-enter-active": "k-push-right-enter-active",
  "push-right-appear-active": "k-push-right-appear-active",
  "push-right-exit": "k-push-right-exit",
  "push-right-exit-active": "k-push-right-exit-active",
  "push-left-enter": "k-push-left-enter",
  "push-left-appear": "k-push-left-appear",
  "push-left-enter-active": "k-push-left-enter-active",
  "push-left-appear-active": "k-push-left-appear-active",
  "push-left-exit": "k-push-left-exit",
  "push-left-exit-active": "k-push-left-exit-active",
  "push-down-enter": "k-push-down-enter",
  "push-down-appear": "k-push-down-appear",
  "push-down-enter-active": "k-push-down-enter-active",
  "push-down-appear-active": "k-push-down-appear-active",
  "push-down-exit": "k-push-down-exit",
  "push-down-exit-active": "k-push-down-exit-active",
  "push-up-enter": "k-push-up-enter",
  "push-up-appear": "k-push-up-appear",
  "push-up-enter-active": "k-push-up-enter-active",
  "push-up-appear-active": "k-push-up-appear-active",
  "push-up-exit": "k-push-up-exit",
  "push-up-exit-active": "k-push-up-exit-active",
  "expand": "k-expand",
  "expand-vertical-enter": "k-expand-vertical-enter",
  "expand-vertical-appear": "k-expand-vertical-appear",
  "expand-vertical-enter-active": "k-expand-vertical-enter-active",
  "expand-vertical-appear-active": "k-expand-vertical-appear-active",
  "expand-vertical-exit": "k-expand-vertical-exit",
  "expand-vertical-exit-active": "k-expand-vertical-exit-active",
  "expand-horizontal-enter": "k-expand-horizontal-enter",
  "expand-horizontal-appear": "k-expand-horizontal-appear",
  "expand-horizontal-enter-active": "k-expand-horizontal-enter-active",
  "expand-horizontal-appear-active": "k-expand-horizontal-appear-active",
  "expand-horizontal-exit": "k-expand-horizontal-exit",
  "expand-horizontal-exit-active": "k-expand-horizontal-exit-active",
  "child-animation-container": "k-child-animation-container",
  "fade-enter": "k-fade-enter",
  "fade-appear": "k-fade-appear",
  "fade-enter-active": "k-fade-enter-active",
  "fade-appear-active": "k-fade-appear-active",
  "fade-exit": "k-fade-exit",
  "fade-exit-active": "k-fade-exit-active",
  "zoom-in-enter": "k-zoom-in-enter",
  "zoom-in-appear": "k-zoom-in-appear",
  "zoom-in-enter-active": "k-zoom-in-enter-active",
  "zoom-in-appear-active": "k-zoom-in-appear-active",
  "zoom-in-exit": "k-zoom-in-exit",
  "zoom-in-exit-active": "k-zoom-in-exit-active",
  "zoom-out-enter": "k-zoom-out-enter",
  "zoom-out-appear": "k-zoom-out-appear",
  "zoom-out-enter-active": "k-zoom-out-enter-active",
  "zoom-out-appear-active": "k-zoom-out-appear-active",
  "zoom-out-exit": "k-zoom-out-exit",
  "zoom-out-exit-active": "k-zoom-out-exit-active",
  "slide-in-appear": "k-slide-in-appear",
  "centered": "k-centered",
  "slide-in-appear-active": "k-slide-in-appear-active",
  "slide-down-enter": "k-slide-down-enter",
  "slide-down-appear": "k-slide-down-appear",
  "slide-down-enter-active": "k-slide-down-enter-active",
  "slide-down-appear-active": "k-slide-down-appear-active",
  "slide-down-exit": "k-slide-down-exit",
  "slide-down-exit-active": "k-slide-down-exit-active",
  "slide-up-enter": "k-slide-up-enter",
  "slide-up-appear": "k-slide-up-appear",
  "slide-up-enter-active": "k-slide-up-enter-active",
  "slide-up-appear-active": "k-slide-up-appear-active",
  "slide-up-exit": "k-slide-up-exit",
  "slide-up-exit-active": "k-slide-up-exit-active",
  "slide-right-enter": "k-slide-right-enter",
  "slide-right-appear": "k-slide-right-appear",
  "slide-right-enter-active": "k-slide-right-enter-active",
  "slide-right-appear-active": "k-slide-right-appear-active",
  "slide-right-exit": "k-slide-right-exit",
  "slide-right-exit-active": "k-slide-right-exit-active",
  "slide-left-enter": "k-slide-left-enter",
  "slide-left-appear": "k-slide-left-appear",
  "slide-left-enter-active": "k-slide-left-enter-active",
  "slide-left-appear-active": "k-slide-left-appear-active",
  "slide-left-exit": "k-slide-left-exit",
  "slide-left-exit-active": "k-slide-left-exit-active",
  "reveal-vertical-enter": "k-reveal-vertical-enter",
  "reveal-vertical-appear": "k-reveal-vertical-appear",
  "reveal-vertical-enter-active": "k-reveal-vertical-enter-active",
  "reveal-vertical-appear-active": "k-reveal-vertical-appear-active",
  "reveal-vertical-exit": "k-reveal-vertical-exit",
  "reveal-vertical-exit-active": "k-reveal-vertical-exit-active",
  "reveal-horizontal-enter": "k-reveal-horizontal-enter",
  "reveal-horizontal-appear": "k-reveal-horizontal-appear",
  "reveal-horizontal-enter-active": "k-reveal-horizontal-enter-active",
  "reveal-horizontal-appear-active": "k-reveal-horizontal-appear-active",
  "reveal-horizontal-exit": "k-reveal-horizontal-exit",
  "reveal-horizontal-exit-active": "k-reveal-horizontal-exit-active"
};
var util_default = {
  outerHeight,
  outerWidth,
  styles
};

// node_modules/@progress/kendo-vue-common/dist/es/isObject.js
var isObject = function(value) {
  return typeof value === "object";
};

// node_modules/@progress/kendo-vue-common/dist/es/classNames.js
var classNames = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return args.filter(function(arg) {
    return arg !== true && !!arg;
  }).map(function(arg) {
    return Array.isArray(arg) ? classNames.apply(void 0, arg) : isObject(arg) ? Object.keys(arg).map(function(key, idx) {
      return arg[idx] || arg[key] && key || null;
    }).filter(function(el) {
      return el !== null;
    }).join(" ") : arg;
  }).filter(function(arg) {
    return !!arg;
  }).join(" ");
};

// node_modules/@progress/kendo-vue-common/dist/es/guid.js
var guid = function() {
  var id = "";
  var i;
  var random;
  for (i = 0; i < 32; i++) {
    random = Math.random() * 16 | 0;
    if (i === 8 || i === 12 || i === 16 || i === 20) {
      id += "-";
    }
    id += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);
  }
  return id;
};

// node_modules/@progress/kendo-vue-common/dist/es/keys.js
var Keys = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  esc: 27,
  space: 32,
  pageUp: 33,
  pageDown: 34,
  end: 35,
  home: 36,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  delete: 46
};

// node_modules/@progress/kendo-vue-common/dist/es/canUseDOM.js
var canUseDOM = Boolean(typeof window !== "undefined" && window.document && window.document.createElement);

// node_modules/@progress/kendo-vue-common/dist/es/focus.js
var focusFirstFocusableChild = function(element) {
  if (element) {
    var elements = element.querySelectorAll('input, [tabindex]:not([tabindex="-1"])');
    if (elements.length && elements[0].focus) {
      elements[0].focus();
    }
  }
};

// node_modules/@progress/kendo-draggable/dist/es/main.js
var proxy = function(a, b) {
  return function(e) {
    return b(a(e));
  };
};
var bind = function(el, event, callback) {
  return el.addEventListener && el.addEventListener(event, callback);
};
var unbind = function(el, event, callback) {
  return el && el.removeEventListener && el.removeEventListener(event, callback);
};
var noop = function() {
};
var preventDefault = function(e) {
  return e.preventDefault();
};
var touchRegExp = /touch/;
var IGNORE_MOUSE_TIMEOUT = 2e3;
function normalizeEvent(e) {
  if (e.type.match(touchRegExp)) {
    return {
      pageX: e.changedTouches[0].pageX,
      pageY: e.changedTouches[0].pageY,
      clientX: e.changedTouches[0].clientX,
      clientY: e.changedTouches[0].clientY,
      type: e.type,
      originalEvent: e,
      isTouch: true
    };
  }
  return {
    pageX: e.pageX,
    pageY: e.pageY,
    clientX: e.clientX,
    clientY: e.clientY,
    offsetX: e.offsetX,
    offsetY: e.offsetY,
    type: e.type,
    ctrlKey: e.ctrlKey,
    shiftKey: e.shiftKey,
    altKey: e.altKey,
    originalEvent: e
  };
}
var Draggable = function Draggable2(ref2) {
  var this$1 = this;
  var press2 = ref2.press;
  if (press2 === void 0)
    press2 = noop;
  var drag2 = ref2.drag;
  if (drag2 === void 0)
    drag2 = noop;
  var release2 = ref2.release;
  if (release2 === void 0)
    release2 = noop;
  var mouseOnly = ref2.mouseOnly;
  if (mouseOnly === void 0)
    mouseOnly = false;
  this._pressHandler = proxy(normalizeEvent, press2);
  this._dragHandler = proxy(normalizeEvent, drag2);
  this._releaseHandler = proxy(normalizeEvent, release2);
  this._ignoreMouse = false;
  this._mouseOnly = mouseOnly;
  this._touchstart = function(e) {
    if (e.touches.length === 1) {
      this$1._pressHandler(e);
    }
  };
  this._touchmove = function(e) {
    if (e.touches.length === 1) {
      this$1._dragHandler(e);
    }
  };
  this._touchend = function(e) {
    if (e.touches.length === 0 && e.changedTouches.length === 1) {
      this$1._releaseHandler(e);
      this$1._ignoreMouse = true;
      setTimeout(this$1._restoreMouse, IGNORE_MOUSE_TIMEOUT);
    }
  };
  this._restoreMouse = function() {
    this$1._ignoreMouse = false;
  };
  this._mousedown = function(e) {
    var which = e.which;
    if (which && which > 1 || this$1._ignoreMouse) {
      return;
    }
    bind(this$1.document, "mousemove", this$1._mousemove);
    bind(this$1.document, "mouseup", this$1._mouseup);
    this$1._pressHandler(e);
  };
  this._mousemove = function(e) {
    this$1._dragHandler(e);
  };
  this._mouseup = function(e) {
    unbind(this$1.document, "mousemove", this$1._mousemove);
    unbind(this$1.document, "mouseup", this$1._mouseup);
    this$1._releaseHandler(e);
  };
  this._pointerdown = function(e) {
    if (e.isPrimary && e.button === 0) {
      bind(this$1.document, "pointermove", this$1._pointermove);
      bind(this$1.document, "pointerup", this$1._pointerup);
      bind(this$1.document, "pointercancel", this$1._pointerup);
      bind(this$1.document, "contextmenu", preventDefault);
      this$1._pressHandler(e);
    }
  };
  this._pointermove = function(e) {
    if (e.isPrimary) {
      this$1._dragHandler(e);
    }
  };
  this._pointerup = function(e) {
    if (e.isPrimary) {
      unbind(this$1.document, "pointermove", this$1._pointermove);
      unbind(this$1.document, "pointerup", this$1._pointerup);
      unbind(this$1.document, "pointercancel", this$1._pointerup);
      unbind(this$1.document, "contextmenu", preventDefault);
      this$1._releaseHandler(e);
    }
  };
};
var prototypeAccessors = { document: { configurable: true } };
Draggable.supportPointerEvent = function supportPointerEvent() {
  return typeof window !== "undefined" && window.PointerEvent;
};
prototypeAccessors.document.get = function() {
  return this._element ? this._element.ownerDocument : document;
};
Draggable.prototype.bindTo = function bindTo(element) {
  if (element === this._element) {
    return;
  }
  if (this._element) {
    this._unbindFromCurrent();
  }
  this._element = element;
  this._bindToCurrent();
};
Draggable.prototype._bindToCurrent = function _bindToCurrent() {
  var element = this._element;
  if (this._usePointers()) {
    bind(element, "pointerdown", this._pointerdown);
    return;
  }
  bind(element, "mousedown", this._mousedown);
  if (!this._mouseOnly) {
    bind(element, "touchstart", this._touchstart);
    bind(element, "touchmove", this._touchmove);
    bind(element, "touchend", this._touchend);
  }
};
Draggable.prototype._unbindFromCurrent = function _unbindFromCurrent() {
  var element = this._element;
  if (this._usePointers()) {
    unbind(element, "pointerdown", this._pointerdown);
    unbind(this.document, "pointermove", this._pointermove);
    unbind(this.document, "pointerup", this._pointerup);
    unbind(this.document, "contextmenu", preventDefault);
    unbind(this.document, "pointercancel", this._pointerup);
    return;
  }
  unbind(element, "mousedown", this._mousedown);
  if (!this._mouseOnly) {
    unbind(element, "touchstart", this._touchstart);
    unbind(element, "touchmove", this._touchmove);
    unbind(element, "touchend", this._touchend);
  }
};
Draggable.prototype._usePointers = function _usePointers() {
  return !this._mouseOnly && Draggable.supportPointerEvent();
};
Draggable.prototype.update = function update(ref2) {
  var press2 = ref2.press;
  if (press2 === void 0)
    press2 = noop;
  var drag2 = ref2.drag;
  if (drag2 === void 0)
    drag2 = noop;
  var release2 = ref2.release;
  if (release2 === void 0)
    release2 = noop;
  var mouseOnly = ref2.mouseOnly;
  if (mouseOnly === void 0)
    mouseOnly = false;
  this._pressHandler = proxy(normalizeEvent, press2);
  this._dragHandler = proxy(normalizeEvent, drag2);
  this._releaseHandler = proxy(normalizeEvent, release2);
  this._mouseOnly = mouseOnly;
};
Draggable.prototype.destroy = function destroy() {
  this._unbindFromCurrent();
  this._element = null;
};
Object.defineProperties(Draggable.prototype, prototypeAccessors);
Draggable.default = Draggable;
var main_default = Draggable;

// node_modules/@progress/kendo-vue-common/dist/es/defaultSlots.js
function getDefaultSlots(component) {
  var defaultSlots = component.$slots.default;
  return component.v3 && defaultSlots && typeof defaultSlots === "function" ? defaultSlots() : defaultSlots;
}

// node_modules/@progress/kendo-vue-common/dist/es/Draggable.js
var _DraggableVue;
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var allVue = vue_runtime_esm_bundler_exports;
var gh = allVue.h;
var DraggableVue2 = (_DraggableVue = {
  emits: {
    press: null,
    drag: null,
    release: null
  },
  inheritAttrs: false,
  created: function created() {
    this.element = null;
    this.draggable = new main_default({
      press: this.press,
      drag: this.drag,
      release: this.release
    });
  },
  setup: !gh ? void 0 : function() {
    var v3 = !!gh;
    return {
      v3
    };
  },
  mounted: function mounted() {
    if (this.$el) {
      this.element = this.$el.nodeType === 3 ? this.$el.nextElementSibling : this.$el;
      this.draggable.bindTo(this.element);
    }
  },
  destroyed: !!gh ? void 0 : function() {
    this.draggable.destroy();
  },
  unmounted: function unmounted() {
    this.draggable.destroy();
  },
  methods: {
    press: function press(event) {
      if (this.element) {
        this.$emit("press", event, this.element);
      }
    },
    drag: function drag(event) {
      if (this.element) {
        this.$emit("drag", event, this.element);
      }
    },
    release: function release(event) {
      if (this.element) {
        this.$emit("release", event, this.element);
      }
    }
  }
}, _defineProperty(_DraggableVue, "setup", !gh ? void 0 : function() {
  var v3 = !!gh;
  return {
    v3
  };
}), _defineProperty(_DraggableVue, "render", function render(createElement) {
  var h = gh || createElement;
  return getDefaultSlots(this);
}), _DraggableVue);
var Draggable3 = DraggableVue2;

// node_modules/@progress/kendo-vue-common/dist/es/noop.js
var noop2 = function() {
};

// node_modules/@progress/kendo-vue-common/dist/es/getter.js
var getterCache = {};
getterCache.undefined = function() {
  return void 0;
};

// node_modules/@progress/kendo-vue-common/dist/es/setter.js
var setterCache = {};
setterCache.undefined = function(obj) {
  return obj;
};

// node_modules/@progress/kendo-vue-common/dist/es/listeners.js
function getListeners() {
  if (this.v3) {
    var listeners = {};
    for (var key in this.$attrs) {
      if (key.startsWith("on")) {
        listeners[key] = this.$attrs[key];
      }
    }
    return listeners;
  } else {
    return this.$listeners;
  }
}

// node_modules/@progress/kendo-vue-common/dist/es/templateRendering.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var allVue2 = vue_runtime_esm_bundler_exports;
var gh2 = allVue2.h;
function templateRendering(template, listeners) {
  if (!template && template !== false) {
    return void 0;
  }
  var scopedSlot = gh2 ? this.$slots[template] || (template.toLowerCase ? this.$slots[template.toLowerCase()] : null) : this.$scopedSlots[template] || (template.toLowerCase ? this.$scopedSlots[template.toLowerCase()] : null);
  if (typeof template === "string" && scopedSlot) {
    return { kt: true, type: "slot", render: scopedSlot, listeners };
  }
  if (typeof template === "string" || isObject(template) || typeof template === "function" && template.component) {
    return { kt: true, type: "component", render: template, listeners };
  }
  return { kt: true, type: "renderFunction", render: template, listeners };
}
function getTemplate(_a) {
  var h = _a.h, template = _a.template, defaultRendering = _a.defaultRendering, defaultSlots = _a.defaultSlots, additionalProps = _a.additionalProps, additionalListeners = _a.additionalListeners, swapDefaultSlots = _a.swapDefaultSlots;
  if (!template || template && template.render === true) {
    return defaultRendering;
  }
  var events;
  var props;
  var componentOptions;
  if (gh2) {
    var passedProps = defaultRendering ? defaultRendering.props : {};
    events = __assign(__assign({}, transformListeners(additionalListeners)), template.listeners);
    props = __assign(__assign(__assign({}, passedProps), additionalProps), events);
    componentOptions = __assign(__assign({}, props), events);
  } else {
    var hasComponentOptions = defaultRendering && defaultRendering.componentOptions;
    var defaultListeners = hasComponentOptions ? defaultRendering.componentOptions.listeners : {};
    var defaultProps = hasComponentOptions ? defaultRendering.componentOptions.propsData : {};
    events = __assign(__assign(__assign(__assign({}, defaultListeners), additionalListeners), transformListeners(additionalListeners)), template.listeners);
    props = __assign(__assign(__assign({}, defaultProps), additionalProps), events);
    componentOptions = { props, on: events };
  }
  if (template.type === "slot") {
    var slotTemplate = template.render({
      props,
      listeners: events,
      methods: events,
      defaultSlots
    });
    return slotTemplate ? slotTemplate[0] : void 0;
  } else if (template.type === "renderFunction") {
    if (swapDefaultSlots) {
      return template.render ? template.render(h, defaultRendering, defaultSlots, props, events) : void 0;
    }
    return template.render ? template.render(h, defaultRendering, props, events, defaultSlots) : void 0;
  } else {
    return h(template.render, componentOptions, gh2 ? function() {
      return [defaultSlots];
    } : [defaultSlots]);
  }
}
function transformListeners(listeners) {
  if (!listeners) {
    return listeners;
  }
  var newListeners = {};
  var listenersKeys = Object.keys(listeners);
  for (var i = 0; i < listenersKeys.length; i++) {
    var currentKey = listenersKeys[i];
    newListeners["on" + currentKey.charAt(0).toUpperCase() + currentKey.slice(1)] = listeners[currentKey];
  }
  return newListeners;
}

// node_modules/@progress/kendo-vue-common/dist/es/getTabIndex.js
var DISABLED_TABINDEX = -1;
var DEFAULT_TABINDEX = 0;
var getTabIndex = function(tabIndex, disabled, useDefaultTabIndexWhenDisabled) {
  var parsedTabIndex = typeof tabIndex === "string" ? parseInt(tabIndex, void 0) : tabIndex;
  if (parsedTabIndex === NaN) {
    return void 0;
  }
  return parsedTabIndex !== void 0 ? parsedTabIndex : disabled ? useDefaultTabIndexWhenDisabled ? void 0 : DISABLED_TABINDEX : DEFAULT_TABINDEX;
};

// node_modules/@progress/kendo-vue-common/dist/es/isRtl.js
function isRtl(element) {
  return Boolean(canUseDOM && element && getComputedStyle(element).direction === "rtl");
}
function getDir(element, initialDir) {
  if (!initialDir && canUseDOM && element) {
    var rtlCandidate = window.getComputedStyle(element).direction;
    if (rtlCandidate) {
      return rtlCandidate;
    }
  }
  return initialDir;
}

// node_modules/@progress/kendo-licensing/dist/index-esm.js
var index_esm_exports = {};
__export(index_esm_exports, {
  setScriptKey: () => setScriptKey,
  validatePackage: () => validatePackage
});
var _0x3282 = ["AgfZ", "turOExC=", "zNvUy3rPB24=", "z3jVDxa=", "ChvIBgLZAerHDgu=", "zgf0yq==", "DgLTzxn0yw1W", "vM5SC2O=", "rejpz2u=", "DfvPvvq=", "D01gsvi=", "u0Xdu2y=", "C2nYAxb0s2v5", "Dg9mB2nHBgvtDhjPBMC=", "r3bNtu8=", "C2v0", "ChjVzhvJDe5HBwu=", "BgLJzw5ZAw5Nrg9JC1vYBa==", "vgHLihbYB2r1y3qGAxmGBM90igLUy2X1zgvKigLUihrOzsbSAwnLBNnLlGO=", "DMvYC2LVBG==", "C1DHyu0=", "ChjVzhvJDhm=", "CNfLrgK=", "uKP0uwG=", "CgfYC2u=", "y3DYvhq=", "zxHWAxj5rgf0zq==", "uMLXufK=", "tM8GBgLJzw5ZzsbMB3vUzc4k", "tNz1Awe=", "z3jVDxbfBMq=", "sK1Vvey=", "zMLUza==", "D2fYBG==", "tfDRtxq=", "CgfJA2fNzu5HBwu=", "Dw5KzwzPBMvK", "C3niBfO=", "BgLJzw5Zzuv4CgLYyxrPB25eyxrL", "ChjVzhvJDenVzgvZ", "tgLJzw5ZzsbHy3rPDMf0Aw9UigzHAwXLzcbMB3iG", "uhjVz3jLC3mG", "tfLwDLa=", "BgvUz3rO", "lcb0AguGCgfJA2fNzsb3yxmGChvIBgLZAgvKig9Uia==", "uvPnu2m=", "BMfTzq==", "B2jQzwn0", "igzVCIbTB3jLigLUzM9YBwf0Aw9UlGO=", "zvn3tLG=", "u2vLia==", "s0PPBvO=", "zxbwz0u=", "zg9JC1vYBa==", "z2v0", "DhLWzq==", "y29Kzq==", "ww91CIbSAwnLBNnLigv4CgLYzwqGB24G"];
(function(_0x456c2b, _0x328245) {
  var _0x5a5cad = function(_0x97df7c) {
    while (--_0x97df7c) {
      _0x456c2b["push"](_0x456c2b["shift"]());
    }
  };
  _0x5a5cad(++_0x328245);
})(_0x3282, 391);
var _0x5a5c = function(_0x456c2b, _0x328245) {
  _0x456c2b = _0x456c2b - 0;
  var _0x5a5cad = _0x3282[_0x456c2b];
  if (_0x5a5c["IhMVZF"] === void 0) {
    var _0x97df7c = function(_0xf176a0) {
      var _0x2f5c1a = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=", _0xc2d087 = String(_0xf176a0)["replace"](/=+$/, "");
      var _0x4465a8 = "";
      for (var _0x56daec = 0, _0x42848b, _0x544e1d2, _0x2bb26d2 = 0; _0x544e1d2 = _0xc2d087["charAt"](_0x2bb26d2++); ~_0x544e1d2 && (_0x42848b = _0x56daec % 4 ? _0x42848b * 64 + _0x544e1d2 : _0x544e1d2, _0x56daec++ % 4) ? _0x4465a8 += String["fromCharCode"](255 & _0x42848b >> (-2 * _0x56daec & 6)) : 0) {
        _0x544e1d2 = _0x2f5c1a["indexOf"](_0x544e1d2);
      }
      return _0x4465a8;
    };
    _0x5a5c["uAzrZg"] = function(_0x4f259a) {
      var _0x1b5199 = _0x97df7c(_0x4f259a);
      var _0x10f781 = [];
      for (var _0x2b16412 = 0, _0x36436a2 = _0x1b5199["length"]; _0x2b16412 < _0x36436a2; _0x2b16412++) {
        _0x10f781 += "%" + ("00" + _0x1b5199["charCodeAt"](_0x2b16412)["toString"](16))["slice"](-2);
      }
      return decodeURIComponent(_0x10f781);
    }, _0x5a5c["jhAfvh"] = {}, _0x5a5c["IhMVZF"] = !![];
  }
  var _0x49ba15 = _0x5a5c["jhAfvh"][_0x456c2b];
  return _0x49ba15 === void 0 ? (_0x5a5cad = _0x5a5c["uAzrZg"](_0x5a5cad), _0x5a5c["jhAfvh"][_0x456c2b] = _0x5a5cad) : _0x5a5cad = _0x49ba15, _0x5a5cad;
};
var context = { data: '  {"timestamp":1657119764,"products":[{"trial":true,"code":"KENDOUIVUE","licenseExpirationDate":1659675281}],"integrity":"wGEYlrIOLrPIs1nyMc28bRN6CXE="}  ' };
var cache = /* @__PURE__ */ new Map();
function setScriptKey(_0x3f7888) {
}
function validatePackage(_0x4a1050) {
  if (cache[_0x5a5c("0xf")](_0x4a1050[_0x5a5c("0x3")])) {
    if (_0x5a5c("0x8") !== _0x5a5c("0x8")) {
      let _0x153d7b = function() {
        var _0x6f019e = _0x5a5c("0x37") + _0x93d1e0[_0x5a5c("0x32")] + "\n";
        if (_0x1d58e3[_0x5a5c("0xc")] === 2)
          _0x6f019e += _0x5a5c("0xe") + _0x3814cc[_0x5a5c("0x29")][_0x5a5c("0x1c")]() + _0x5a5c("0x1") + _0x105281[_0x5a5c("0x13")][_0x5a5c("0x1c")]() + ".\n";
        else {
          if (_0x333263[_0x5a5c("0xc")] === 0)
            _0x6f019e += _0x5a5c("0x2b");
          else
            _0x281f6e[_0x5a5c("0xc")] === 1 && (_0x6f019e += _0x5a5c("0x21"));
        }
        return _0x6f019e += _0x5a5c("0x7") + _0xaa3d77[_0x5a5c("0xa")] + _0x5a5c("0x5"), _0x6f019e;
      };
    } else
      return cache[_0x5a5c("0xb")](_0x4a1050[_0x5a5c("0x3")]);
  }
  var _0x5f3536 = _0x4a1050[_0x5a5c("0x22")] ? " v" + _0x4a1050[_0x5a5c("0x22")] : "", _0x28c95f = _0x4a1050[_0x5a5c("0x3")] + _0x5f3536, _0x354beb = JSON[_0x5a5c("0x27")](context[_0x5a5c("0x14")]), _0x236cba = !_0x354beb[_0x5a5c("0x1b")] && !_0x354beb[_0x5a5c("0x15")], _0x1e1a8d = _0x354beb[_0x5a5c("0x1b")] && typeof KendoLicensing === _0x5a5c("0x33"), _0x232f89 = matchProduct(_0x354beb, _0x4a1050[_0x5a5c("0x36")]), _0x493c49;
  if (_0x236cba || _0x1e1a8d) {
    if (_0x5a5c("0x1d") === _0x5a5c("0x1d"))
      _0x493c49 = { "type": 0, "packageName": _0x28c95f, "docsUrl": _0x4a1050[_0x5a5c("0x20")] };
    else {
      let _0x38933e = function() {
        var _0x3a76ad = _0x5a5c("0x38") + _0x160df8[_0x5a5c("0x1f")], _0x46900d = typeof _0x4c5dc3[_0x5a5c("0x12")] === _0x5a5c("0x11");
        _0x46900d ? _0x3c6396[_0x5a5c("0x12")](_0x3a76ad) : _0x156a7a[_0x5a5c("0x30")](_0x3a76ad), _0x3a6cc8[_0x5a5c("0x30")](_0x20d0d4(_0x4b3d98)), _0x46900d && _0x126050[_0x5a5c("0x2d")]();
      };
    }
  } else {
    if (_0x5a5c("0x25") === _0x5a5c("0x10")) {
      let _0x2eedf9 = function() {
        _0x5c9d09 = { "type": 1, "packageName": _0x1b4532, "docsUrl": _0x2c67b6[_0x5a5c("0x20")] };
      };
    } else {
      if (!_0x232f89) {
        if (_0x5a5c("0x31") !== _0x5a5c("0x31")) {
          let _0x43e69f = function() {
            _0x2b1641 = { "type": 0, "packageName": _0x36436a, "docsUrl": _0x3d5bc8[_0x5a5c("0x20")] };
          };
        } else
          _0x493c49 = { "type": 1, "packageName": _0x28c95f, "docsUrl": _0x4a1050[_0x5a5c("0x20")] };
      } else {
        if (_0x5a5c("0x6") === _0x5a5c("0x2")) {
          let _0x1a3b76 = function() {
            _0x88b173 = { "type": 2, "packageName": _0x7a4b9, "publishDate": _0x272f8c(_0x2e605a[_0x5a5c("0x13")]), "expiryDate": _0x27f75b(_0x1ae22c[_0x5a5c("0x35")]), "docsUrl": _0x493ad8[_0x5a5c("0x20")] };
          };
        } else {
          if (_0x232f89[_0x5a5c("0x35")] < _0x4a1050[_0x5a5c("0x13")]) {
            if (_0x5a5c("0x2e") === _0x5a5c("0x2e"))
              _0x493c49 = { "type": 2, "packageName": _0x28c95f, "publishDate": parseDate(_0x4a1050[_0x5a5c("0x13")]), "expiryDate": parseDate(_0x232f89[_0x5a5c("0x35")]), "docsUrl": _0x4a1050[_0x5a5c("0x20")] };
            else {
              let _0x5b1451 = function() {
                return new _0x5de45c(_0x354370 * 1e3);
              };
            }
          }
        }
      }
    }
  }
  if (_0x493c49 && typeof console === _0x5a5c("0x4")) {
    if (_0x5a5c("0x17") !== _0x5a5c("0x2c")) {
      var _0x3e1208 = _0x5a5c("0x38") + _0x4a1050[_0x5a5c("0x1f")], _0x11fad5 = typeof console[_0x5a5c("0x12")] === _0x5a5c("0x11");
      if (_0x11fad5) {
        if (_0x5a5c("0x18") === _0x5a5c("0x18"))
          console[_0x5a5c("0x12")](_0x3e1208);
        else {
          let _0x2ca9f1 = function() {
            _0x4b304a += _0x5a5c("0x2b");
          };
        }
      } else {
        if (_0x5a5c("0x2a") === _0x5a5c("0x2a"))
          console[_0x5a5c("0x30")](_0x3e1208);
        else {
          let _0x22229f = function() {
            _0x560756[_0x5a5c("0x30")](_0x5cc11d);
          };
        }
      }
      console[_0x5a5c("0x30")](formatError(_0x493c49));
      if (_0x11fad5) {
        if (_0x5a5c("0x19") !== _0x5a5c("0x19")) {
          let _0x1ba7c1 = function() {
            return _0x5853d5[_0x5a5c("0xf")](_0x8ce849[_0x5a5c("0xd")]);
          };
        } else
          console[_0x5a5c("0x2d")]();
      }
    } else {
      let _0x144f55 = function() {
        return _0x544e1d[_0x5a5c("0xb")](_0x2bb26d[_0x5a5c("0x3")]);
      };
    }
  }
  var _0x40a89d = !_0x493c49;
  return cache[_0x5a5c("0x1e")](_0x4a1050[_0x5a5c("0x3")], _0x40a89d), _0x40a89d;
}
function formatError(_0x2bf099) {
  var _0x3b8354 = _0x5a5c("0x37") + _0x2bf099[_0x5a5c("0x32")] + "\n";
  if (_0x2bf099[_0x5a5c("0xc")] === 2) {
    if (_0x5a5c("0x16") !== _0x5a5c("0x16")) {
      let _0x333f51 = function() {
        _0x1cd78a += _0x5a5c("0xe") + _0x1069cf[_0x5a5c("0x29")][_0x5a5c("0x1c")]() + _0x5a5c("0x1") + _0x58f1d3[_0x5a5c("0x13")][_0x5a5c("0x1c")]() + ".\n";
      };
    } else
      _0x3b8354 += _0x5a5c("0xe") + _0x2bf099[_0x5a5c("0x29")][_0x5a5c("0x1c")]() + _0x5a5c("0x1") + _0x2bf099[_0x5a5c("0x13")][_0x5a5c("0x1c")]() + ".\n";
  } else {
    if (_0x2bf099[_0x5a5c("0xc")] === 0) {
      if (_0x5a5c("0x28") === _0x5a5c("0x34")) {
        let _0x2de46a = function() {
          _0x44d8f3 += _0x5a5c("0x21");
        };
      } else
        _0x3b8354 += _0x5a5c("0x2b");
    } else {
      if (_0x2bf099[_0x5a5c("0xc")] === 1) {
        if (_0x5a5c("0x9") === _0x5a5c("0x1a")) {
          let _0x42e868 = function() {
            _0x3c8674[_0x5a5c("0x12")](_0x3c7683);
          };
        } else
          _0x3b8354 += _0x5a5c("0x21");
      }
    }
  }
  return _0x3b8354 += _0x5a5c("0x7") + _0x2bf099[_0x5a5c("0xa")] + _0x5a5c("0x5"), _0x3b8354;
}
function matchProduct(_0x3be8d0, _0x22e53b) {
  var _0x2de868 = _0x3be8d0[_0x5a5c("0x24")];
  if (!_0x2de868 || !_0x2de868[_0x5a5c("0x0")]) {
    if (_0x5a5c("0x26") === _0x5a5c("0x23")) {
      let _0x2ce30d = function() {
        return null;
      };
    } else
      return null;
  }
  var _0x1c39ae = new Set(_0x22e53b);
  return _0x2de868[_0x5a5c("0x2f")](function(_0xf8b567) {
    if (_0x5a5c("0x39") === _0x5a5c("0x39"))
      return _0x1c39ae[_0x5a5c("0xf")](_0xf8b567[_0x5a5c("0xd")]);
    else {
      let _0x2ffdc4 = function() {
        var _0x287464 = _0x41d50e[_0x5a5c("0x24")];
        if (!_0x287464 || !_0x287464[_0x5a5c("0x0")])
          return null;
        var _0x473ae4 = new _0x5ba11e(_0x2ff6bd);
        return _0x287464[_0x5a5c("0x2f")](function(_0x54470f) {
          return _0x473ae4[_0x5a5c("0xf")](_0x54470f[_0x5a5c("0xd")]);
        });
      };
    }
  });
}
function parseDate(_0x15d2db) {
  return new Date(_0x15d2db * 1e3);
}

// node_modules/@progress/kendo-vue-common/dist/es/validate-package.js
function validatePackage2(packageMetadata3) {
  if (typeof index_esm_exports !== "undefined") {
    validatePackage(packageMetadata3);
  } else {
    var message = "License activation failed for " + packageMetadata3.name + "\n";
    message += "The @progress/kendo-licensing script is not loaded.\n";
    message += "See " + packageMetadata3.licensingDocsUrl + " for more information.\n";
    console.warn(message);
  }
}

// node_modules/@progress/kendo-vue-common/dist/es/theme.js
var kendoThemeMaps = {
  sizeMap: {
    small: "sm",
    medium: "md",
    large: "lg"
  },
  roundedMap: {
    small: "sm",
    medium: "md",
    large: "lg"
  }
};

// node_modules/@progress/kendo-vue-popup/node_modules/@progress/kendo-vue-animation/dist/es/AnimationChild.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
      }
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var allVue3 = vue_runtime_esm_bundler_exports;
var gh3 = allVue3.h;
var ref = allVue3.ref;
var Transition = allVue3.Transition;
var styles2 = util_default.styles;
var AnimationChildVue2 = {
  props: {
    in: Boolean,
    transitionName: {
      type: String,
      required: true
    },
    transitionStyle: Object,
    componentChildClassName: [Array],
    className: String,
    appear: {
      type: Boolean,
      default: true
    },
    enter: {
      type: Boolean,
      default: true
    },
    exit: {
      type: Boolean,
      default: true
    },
    transitionEnterDuration: Number,
    transitionExitDuration: Number,
    mountOnEnter: Boolean,
    unmountOnExit: Boolean,
    animationEnteringStyle: Object,
    animationEnteredStyle: Object,
    animationExitingStyle: Object,
    animationExitedStyle: Object
  },
  created: function created2() {
    this.animationStep = "";
  },
  setup: !gh3 ? void 0 : function() {
    var v3 = !!gh3;
    var elementRef = ref(null);
    return {
      v3,
      elementRef
    };
  },
  mounted: function mounted2() {
    this._element = this.v3 ? this.elementRef || null : this.$refs.element || null;
  },
  computed: {
    element: {
      get: function get() {
        return this._element;
      }
    }
  },
  methods: {
    onBeforeEnter: function onBeforeEnter(e) {
      this.$emit("beforeenter", {
        animatedElement: e,
        target: this
      });
    },
    onEnter: function onEnter(e) {
      this.animationStep = "entering";
      this.$emit("entering", {
        animatedElement: e,
        target: this
      });
    },
    onAfterEnter: function onAfterEnter(e) {
      this.animationStep = "entered";
      this.$emit("entered", {
        animatedElement: e,
        target: this
      });
    },
    onBeforeLeave: function onBeforeLeave(e) {
      this.$emit("exit", {
        animatedElement: e,
        target: this
      });
    },
    onLeave: function onLeave(e) {
      this.animationStep = "exiting";
      this.$emit("exiting", {
        animatedElement: e,
        target: this
      });
    },
    onAfterLeave: function onAfterLeave(e) {
      this.animationStep = "exited";
      this.$emit("exited", {
        animatedElement: e,
        target: this
      });
    }
  },
  render: function render2(createElement) {
    var _this = this;
    var h = gh3 || createElement;
    var _a = this.$props, appear = _a.appear, enter = _a.enter, exit = _a.exit, transitionName = _a.transitionName, transitionEnterDuration = _a.transitionEnterDuration, transitionExitDuration = _a.transitionExitDuration, className = _a.className, componentChildClassName = _a.componentChildClassName, mountOnEnter = _a.mountOnEnter, unmountOnExit = _a.unmountOnExit, animationEnteringStyle = _a.animationEnteringStyle, animationEnteredStyle = _a.animationEnteredStyle, animationExitingStyle = _a.animationExitingStyle, animationExitedStyle = _a.animationExitedStyle, other = __rest(_a, ["appear", "enter", "exit", "transitionName", "transitionEnterDuration", "transitionExitDuration", "className", "componentChildClassName", "mountOnEnter", "unmountOnExit", "animationEnteringStyle", "animationEnteredStyle", "animationExitingStyle", "animationExitedStyle"]);
    var defaultSlot = getDefaultSlots(this);
    var hasChildren = this.v3 ? appear : !!defaultSlot;
    var transitionTag = this.v3 ? Transition : "transition";
    var childAnimationContainerClassNames = [componentChildClassName, styles2["child-animation-container"]];
    var enterDuration = enter ? transitionEnterDuration : 0;
    var exitDuration = exit ? transitionExitDuration : 0;
    var defaultStyle = __assign2({
      transitionDelay: "0ms",
      transitionDuration: hasChildren ? enterDuration + "ms" : exitDuration + "ms"
    }, this.$props.transitionStyle);
    var animationStyle = {
      entering: __assign2({
        transitionDuration: enterDuration + "ms"
      }, animationEnteringStyle),
      entered: __assign2({}, animationEnteredStyle),
      exiting: __assign2({
        transitionDuration: exitDuration + "ms"
      }, animationExitingStyle),
      exited: __assign2({}, animationExitedStyle)
    };
    var childElementStyles = [defaultStyle, animationStyle[this.animationStep]];
    var duration = {
      enter: enterDuration,
      leave: exitDuration
    };
    var rendererChildren = [hasChildren ? h("div", {
      style: childElementStyles,
      "class": childAnimationContainerClassNames,
      ref: this.v3 ? function(el) {
        _this.elementRef = el;
      } : "element"
    }, [defaultSlot]) : null];
    return h(transitionTag, {
      duration,
      attrs: this.v3 ? null : {
        duration,
        name: transitionName,
        appear,
        appearClass: styles2[transitionName + "-appear"] || transitionName + "-appear",
        appearToClass: styles2[transitionName + "-appear-active"] || transitionName + "-appear-active",
        enterClass: styles2[transitionName + "-enter"] || transitionName + "-enter",
        enterToClass: styles2[transitionName + "-enter-active"] || transitionName + "-enter-active",
        leaveClass: styles2[transitionName + "-exit"] || transitionName + "-exit",
        leaveToClass: styles2[transitionName + "-exit-active"] || transitionName + "-exit-active"
      },
      name: transitionName,
      appear,
      appearFromClass: styles2[transitionName + "-appear"] || transitionName + "-appear",
      enterFromClass: styles2[transitionName + "-enter"] || transitionName + "-enter",
      leaveFromClass: styles2[transitionName + "-exit"] || transitionName + "-exit",
      appearToClass: styles2[transitionName + "-appear-active"] || transitionName + "-appear-active",
      enterToClass: styles2[transitionName + "-enter-active"] || transitionName + "-enter-active",
      leaveToClass: styles2[transitionName + "-exit-active"] || transitionName + "-exit-active",
      onBeforeEnter: this.onBeforeEnter,
      on: this.v3 ? null : {
        "beforeEnter": this.onBeforeEnter,
        "enter": this.onEnter,
        "afterEnter": this.onAfterEnter,
        "beforeLeave": this.onBeforeLeave,
        "leave": this.onLeave,
        "afterLeave": this.onAfterLeave
      },
      onEnter: this.onEnter,
      onAfterEnter: this.onAfterEnter,
      onBeforeLeave: this.onBeforeLeave,
      onLeave: this.onLeave,
      onAfterLeave: this.onAfterLeave
    }, this.v3 ? function() {
      return rendererChildren;
    } : rendererChildren);
  }
};
var AnimationChild = AnimationChildVue2;

// node_modules/@progress/kendo-vue-popup/node_modules/@progress/kendo-vue-animation/dist/es/package-metadata.js
var packageMetadata = {
  name: "@progress/kendo-vue-animation",
  productName: "Kendo UI for Vue",
  productCodes: ["KENDOUIVUE", "KENDOUICOMPLETE"],
  publishDate: 1656415171,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-vue-ui/my-license/?utm_medium=product&utm_source=kendovue&utm_campaign=kendo-ui-vue-purchase-license-keys-warning"
};

// node_modules/@progress/kendo-vue-popup/node_modules/@progress/kendo-vue-animation/dist/es/Animation.js
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var allVue4 = vue_runtime_esm_bundler_exports;
var gh4 = allVue4.h;
var styles3 = util_default.styles;
var AnimationVue2 = {
  props: {
    childFactory: Object,
    className: String,
    tag: String,
    id: String,
    animationEnteringStyle: Object,
    animationExitingStyle: Object,
    componentChildClassName: [Array],
    transitionName: {
      type: String,
      required: true
    },
    appear: {
      type: Boolean,
      default: true
    },
    enter: {
      type: Boolean,
      default: true
    },
    exit: {
      type: Boolean,
      default: true
    },
    transitionEnterDuration: {
      type: Number
    },
    transitionExitDuration: {
      type: Number
    }
  },
  methods: {
    onEntering: function onEntering(e) {
      this.$emit("entering", e);
    },
    onEnter: function onEnter2(e) {
      this.$emit("enter", e);
    },
    onEntered: function onEntered(e) {
      this.$emit("entered", e);
    },
    onExit: function onExit(e) {
      this.$emit("exit", e);
    },
    onExiting: function onExiting(e) {
      this.$emit("exiting", e);
    },
    onExited: function onExited(e) {
      this.$emit("exited", e);
    }
  },
  setup: !gh4 ? void 0 : function() {
    var v3 = !!gh4;
    return {
      v3
    };
  },
  created: function created3() {
    validatePackage2(packageMetadata);
  },
  render: function render3(createElement) {
    var h = gh4 || createElement;
    var defaultSlot = getDefaultSlots(this);
    var _a = this.$props, id = _a.id, tag = _a.tag, className = _a.className, childFactory = _a.childFactory, stackChildren = _a.stackChildren, componentChildStyle = _a.componentChildStyle, componentChildClassName = _a.componentChildClassName, other = __rest2(_a, ["id", "tag", "className", "childFactory", "stackChildren", "componentChildStyle", "componentChildClassName"]);
    var parentDivClass = [styles3["animation-container"], styles3["animation-container-relative"], className];
    return h("div", {
      id: this.$props.id,
      attrs: this.v3 ? void 0 : {
        id: this.$props.id
      },
      "class": parentDivClass
    }, [
      h(AnimationChild, {
        key: "some",
        appear: this.$props.appear,
        attrs: this.v3 ? void 0 : {
          appear: this.$props.appear,
          enter: this.$props.enter,
          exit: this.$props.exit,
          transitionName: this.$props.transitionName,
          componentChildClassName: this.$props.componentChildClassName,
          animationEnteringStyle: this.$props.animationEnteringStyle,
          animationExitingStyle: this.$props.animationExitingStyle,
          transitionEnterDuration: this.$props.transitionEnterDuration,
          transitionExitDuration: this.$props.transitionExitDuration
        },
        enter: this.$props.enter,
        exit: this.$props.exit,
        transitionName: this.$props.transitionName,
        componentChildClassName: this.$props.componentChildClassName,
        onBeforeenter: this.onEnter,
        on: this.v3 ? void 0 : {
          "beforeenter": this.onEnter,
          "entering": this.onEntering,
          "entered": this.onEntered,
          "exit": this.onExit,
          "exiting": this.onExiting,
          "exited": this.onExited
        },
        onEntering: this.onEntering,
        onEntered: this.onEntered,
        onExit: this.onExit,
        onExiting: this.onExiting,
        onExited: this.onExited,
        animationEnteringStyle: this.$props.animationEnteringStyle,
        animationExitingStyle: this.$props.animationExitingStyle,
        transitionEnterDuration: this.$props.transitionEnterDuration,
        transitionExitDuration: this.$props.transitionExitDuration
      }, this.v3 ? function() {
        return [defaultSlot];
      } : [defaultSlot])
    ]);
  }
};
var Animation = AnimationVue2;

// node_modules/@progress/kendo-vue-popup/node_modules/@progress/kendo-vue-animation/dist/es/Fade.js
var allVue5 = vue_runtime_esm_bundler_exports;
var gh5 = allVue5.h;

// node_modules/@progress/kendo-vue-popup/node_modules/@progress/kendo-vue-animation/dist/es/Expand.js
var allVue6 = vue_runtime_esm_bundler_exports;
var gh6 = allVue6.h;

// node_modules/@progress/kendo-vue-popup/node_modules/@progress/kendo-vue-animation/dist/es/Push.js
var allVue7 = vue_runtime_esm_bundler_exports;
var gh7 = allVue7.h;

// node_modules/@progress/kendo-vue-popup/node_modules/@progress/kendo-vue-animation/dist/es/Slide.js
var __rest3 = function(s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var allVue8 = vue_runtime_esm_bundler_exports;
var gh8 = allVue8.h;
var SlideVue2 = {
  props: {
    appear: {
      type: Boolean,
      default: false
    },
    enter: {
      type: Boolean,
      default: true
    },
    exit: {
      type: Boolean,
      default: true
    },
    transitionEnterDuration: {
      type: Number,
      default: 300
    },
    transitionExitDuration: {
      type: Number,
      default: 300
    },
    componentChildClassName: [Array],
    childFactory: Object,
    className: String,
    direction: {
      type: String,
      default: "down"
    },
    tag: String,
    id: String
  },
  methods: {
    onEntering: function onEntering2(e) {
      this.$emit("entering", e);
    },
    onEnter: function onEnter3(e) {
      this.$emit("enter", e);
    },
    onEntered: function onEntered2(e) {
      this.$emit("entered", e);
    },
    onExit: function onExit2(e) {
      this.$emit("exit", e);
    },
    onExiting: function onExiting2(e) {
      this.$emit("exiting", e);
    },
    onExited: function onExited2(e) {
      this.$emit("exited", e);
    }
  },
  setup: !gh8 ? void 0 : function() {
    var v3 = !!gh8;
    return {
      v3
    };
  },
  render: function render4(createElement) {
    var h = gh8 || createElement;
    var defaultSlot = getDefaultSlots(this);
    var _a = this.$props, direction = _a.direction, id = _a.id, other = __rest3(_a, ["direction", "id"]);
    var transitionName = "slide-" + this.$props.direction;
    return h(Animation, {
      id,
      attrs: this.v3 ? void 0 : {
        id,
        transitionName,
        componentChildClassName: this.$props.componentChildClassName,
        appear: this.$props.appear,
        enter: this.$props.enter,
        exit: this.$props.exit,
        transitionEnterDuration: this.$props.transitionEnterDuration,
        transitionExitDuration: this.$props.transitionExitDuration
      },
      transitionName,
      componentChildClassName: this.$props.componentChildClassName,
      appear: this.$props.appear,
      enter: this.$props.enter,
      exit: this.$props.exit,
      onEnter: this.onEnter,
      on: this.v3 ? void 0 : {
        "enter": this.onEnter,
        "entering": this.onEntering,
        "entered": this.onEntered,
        "exit": this.onExit,
        "exiting": this.onExiting,
        "exited": this.onExited
      },
      onEntering: this.onEntering,
      onEntered: this.onEntered,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited,
      transitionEnterDuration: this.$props.transitionEnterDuration,
      transitionExitDuration: this.$props.transitionExitDuration
    }, this.v3 ? function() {
      return [defaultSlot];
    } : [defaultSlot]);
  }
};
var Slide = SlideVue2;

// node_modules/@progress/kendo-vue-popup/node_modules/@progress/kendo-vue-animation/dist/es/Zoom.js
var allVue9 = vue_runtime_esm_bundler_exports;
var gh9 = allVue9.h;

// node_modules/@progress/kendo-vue-popup/node_modules/@progress/kendo-vue-animation/dist/es/Reveal.js
var allVue10 = vue_runtime_esm_bundler_exports;
var gh10 = allVue10.h;

// node_modules/@progress/kendo-popup-common/dist/es/align-point.js
var align_point_default = {
  "bottom": "bottom",
  "center": "center",
  "middle": "middle",
  "left": "left",
  "right": "right",
  "top": "top"
};

// node_modules/@progress/kendo-popup-common/dist/es/align.js
var align = function(options) {
  var anchorRect = options.anchorRect;
  var anchorAlign = options.anchorAlign;
  var elementRect = options.elementRect;
  var elementAlign = options.elementAlign;
  var margin = options.margin;
  if (margin === void 0)
    margin = {};
  var anchorHorizontal = anchorAlign.horizontal;
  var anchorVertical = anchorAlign.vertical;
  var elementHorizontal = elementAlign.horizontal;
  var elementVertical = elementAlign.vertical;
  var horizontalMargin = margin.horizontal || 0;
  var verticalMargin = margin.vertical || 0;
  var top = anchorRect.top;
  var left = anchorRect.left;
  if (anchorVertical === align_point_default.bottom) {
    top += anchorRect.height;
  }
  if (anchorVertical === align_point_default.center || anchorVertical === align_point_default.middle) {
    top += Math.round(anchorRect.height / 2);
  }
  if (elementVertical === align_point_default.bottom) {
    top -= elementRect.height;
    verticalMargin *= -1;
  }
  if (elementVertical === align_point_default.center || elementVertical === align_point_default.middle) {
    top -= Math.round(elementRect.height / 2);
    verticalMargin *= -1;
  }
  if (anchorHorizontal === align_point_default.right) {
    left += anchorRect.width;
  }
  if (anchorHorizontal === align_point_default.center || anchorHorizontal === align_point_default.middle) {
    left += Math.round(anchorRect.width / 2);
  }
  if (elementHorizontal === align_point_default.right) {
    left -= elementRect.width;
    horizontalMargin *= -1;
  }
  if (elementHorizontal === align_point_default.center || elementHorizontal === align_point_default.middle) {
    left -= Math.round(elementRect.width / 2);
    horizontalMargin *= -1;
  }
  return {
    top: top + verticalMargin,
    left: left + horizontalMargin
  };
};
var align_default = align;

// node_modules/@progress/kendo-popup-common/dist/es/add-scroll.js
function addScroll(rect, scroll) {
  return {
    top: rect.top + scroll.y,
    left: rect.left + scroll.x,
    height: rect.height,
    width: rect.width
  };
}

// node_modules/@progress/kendo-popup-common/dist/es/apply-location-offset.js
function applyLocationOffset(rect, location, isOffsetBody) {
  var top = rect.top;
  var left = rect.left;
  if (isOffsetBody) {
    left = 0;
    top = 0;
  }
  return {
    top: top + location.top,
    left: left + location.left,
    height: rect.height,
    width: rect.width
  };
}

// node_modules/@progress/kendo-popup-common/dist/es/owner-document.js
function ownerDocument(element) {
  return element.ownerDocument || element.document || element;
}

// node_modules/@progress/kendo-popup-common/dist/es/window.js
var getWindow = function(element) {
  return ownerDocument(element).defaultView;
};
var window_default = getWindow;

// node_modules/@progress/kendo-popup-common/dist/es/document.js
var getDocument = function(element) {
  return ownerDocument(element).documentElement;
};
var document_default = getDocument;

// node_modules/@progress/kendo-popup-common/dist/es/scrollbar-width.js
var cachedWidth = 0;
function scrollbarWidth() {
  if (!cachedWidth && typeof document !== "undefined") {
    var div = document.createElement("div");
    div.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block";
    div.innerHTML = "&nbsp;";
    document.body.appendChild(div);
    cachedWidth = div.offsetWidth - div.scrollWidth;
    document.body.removeChild(div);
  }
  return cachedWidth;
}

// node_modules/@progress/kendo-popup-common/dist/es/window-viewport.js
function windowViewport(element) {
  var win = window_default(element);
  var document2 = document_default(element);
  var result = {
    height: win.innerHeight,
    width: win.innerWidth
  };
  if (document2.scrollHeight - document2.clientHeight > 0) {
    result.width -= scrollbarWidth();
  }
  return result;
}

// node_modules/@progress/kendo-popup-common/dist/es/bounding-offset.js
var boundingOffset = function(element) {
  if (!element.getBoundingClientRect) {
    var viewport = windowViewport(element);
    return {
      bottom: viewport.height,
      left: 0,
      right: viewport.width,
      top: 0
    };
  }
  var ref2 = element.getBoundingClientRect();
  var bottom = ref2.bottom;
  var left = ref2.left;
  var right = ref2.right;
  var top = ref2.top;
  return {
    bottom,
    left,
    right,
    top
  };
};
var bounding_offset_default = boundingOffset;

// node_modules/@progress/kendo-popup-common/dist/es/offset-parent.js
var offsetParent = function(element) {
  var offsetParent2 = element.offsetParent;
  while (offsetParent2 && offsetParent2.style.position === "static") {
    offsetParent2 = offsetParent2.offsetParent;
  }
  return offsetParent2 || document_default(element);
};
var offset_parent_default = offsetParent;

// node_modules/@progress/kendo-popup-common/dist/es/is-body-offset.js
var isBodyOffset = function(element) {
  return offset_parent_default(element) === element.ownerDocument.body;
};
var is_body_offset_default = isBodyOffset;

// node_modules/@progress/kendo-popup-common/dist/es/offset.js
var rectOfHiddenElement = function(element) {
  var ref2 = element.style;
  var display = ref2.display;
  var left = ref2.left;
  var position3 = ref2.position;
  element.style.display = "";
  element.style.left = "-10000px";
  element.style.position = "absolute";
  var rect = element.getBoundingClientRect();
  element.style.display = display;
  element.style.left = left;
  element.style.position = position3;
  return rect;
};
var offset = function(element) {
  var rect = element.getBoundingClientRect();
  var left = rect.left;
  var top = rect.top;
  if (!rect.height && !rect.width) {
    rect = rectOfHiddenElement(element);
  }
  return {
    top,
    left,
    height: rect.height,
    width: rect.width
  };
};
var offset_default = offset;

// node_modules/@progress/kendo-popup-common/dist/es/parents.js
function parents_default(element, until) {
  var result = [];
  var next = element.parentNode;
  while (next) {
    result.push(next);
    if (next === until) {
      break;
    }
    next = next.parentNode;
  }
  return result;
}

// node_modules/@progress/kendo-popup-common/dist/es/scroll-position.js
function scrollPosition(element) {
  var documentElement = document_default(element);
  var win = window_default(element);
  return {
    x: win.pageXOffset || documentElement.scrollLeft || 0,
    y: win.pageYOffset || documentElement.scrollTop || 0
  };
}

// node_modules/@progress/kendo-popup-common/dist/es/element-scroll-position.js
function element_scroll_position_default(element) {
  if (element === (element.ownerDocument || {}).body) {
    return scrollPosition(element);
  }
  return {
    x: element.scrollLeft,
    y: element.scrollTop
  };
}

// node_modules/@progress/kendo-popup-common/dist/es/parent-scroll-position.js
function parentScrollPosition(element) {
  var parent = offset_parent_default(element);
  return parent ? element_scroll_position_default(parent) : { x: 0, y: 0 };
}

// node_modules/@progress/kendo-popup-common/dist/es/position.js
var position = function(element, parent) {
  var win = window_default(element);
  var elementStyles = win.getComputedStyle(element);
  var offset2 = offset_default(element);
  var parentElement = parent || offset_parent_default(element);
  var ownerDocument2 = element.ownerDocument;
  var useRelative = parentElement !== ownerDocument2.body && parentElement !== ownerDocument2.documentElement;
  var parentOffset = { top: 0, left: 0 };
  if (elementStyles.position !== "fixed" && useRelative) {
    var parentStyles = win.getComputedStyle(parentElement);
    parentOffset = offset_default(parentElement);
    parentOffset.top += parseInt(parentStyles.borderTopWidth, 10);
    parentOffset.left += parseInt(parentStyles.borderLeftWidth, 10);
  }
  return {
    top: offset2.top - parentOffset.top,
    left: offset2.left - parentOffset.left,
    height: offset2.height,
    width: offset2.width
  };
};
var position_default = position;

// node_modules/@progress/kendo-popup-common/dist/es/offset-parent-scroll-position.js
function offset_parent_scroll_position_default(offsetParentElement, element) {
  return offsetParentElement ? element_scroll_position_default(offsetParentElement) : parentScrollPosition(element);
}

// node_modules/@progress/kendo-popup-common/dist/es/position-with-scroll.js
function position_with_scroll_default(element, parent, scale) {
  if (scale === void 0)
    scale = 1;
  var offsetParentElement = parent ? offset_parent_default(parent) : null;
  var ref2 = position_default(element, offsetParentElement);
  var top = ref2.top;
  var left = ref2.left;
  var height = ref2.height;
  var width = ref2.width;
  var ref$1 = offset_parent_scroll_position_default(offsetParentElement, element);
  var x = ref$1.x;
  var y = ref$1.y;
  var ownerDocument2 = element.ownerDocument;
  var positionScale = offsetParentElement === ownerDocument2.body || offsetParentElement === ownerDocument2.documentElement ? 1 : scale;
  return {
    top: top + y * positionScale,
    left: left + x * positionScale,
    height,
    width
  };
}

// node_modules/@progress/kendo-popup-common/dist/es/remove-scroll.js
function removeScroll(rect, scroll) {
  return {
    top: rect.top - scroll.y,
    left: rect.left - scroll.x,
    height: rect.height,
    width: rect.width
  };
}

// node_modules/@progress/kendo-popup-common/dist/es/collision.js
var collision_default = {
  "fit": "fit",
  "flip": "flip",
  "none": "none"
};

// node_modules/@progress/kendo-popup-common/dist/es/restrict-to-view.js
var fit = function(position3, size, viewPortSize) {
  var output = 0;
  if (position3 + size > viewPortSize) {
    output = viewPortSize - (position3 + size);
  }
  if (position3 < 0) {
    output = -position3;
  }
  return output;
};
var flip = function(ref2) {
  var offset2 = ref2.offset;
  var size = ref2.size;
  var anchorSize = ref2.anchorSize;
  var viewPortSize = ref2.viewPortSize;
  var anchorAlignPoint = ref2.anchorAlignPoint;
  var elementAlignPoint = ref2.elementAlignPoint;
  var margin = ref2.margin;
  var output = 0;
  var isPositionCentered = elementAlignPoint === align_point_default.center || elementAlignPoint === align_point_default.middle;
  var isOriginCentered = anchorAlignPoint === align_point_default.center || anchorAlignPoint === align_point_default.middle;
  var marginToAdd = 2 * margin;
  if (elementAlignPoint !== anchorAlignPoint && !isPositionCentered && !isOriginCentered) {
    var isBeforeAnchor = anchorAlignPoint === align_point_default.top || anchorAlignPoint === align_point_default.left;
    if (offset2 < 0 && isBeforeAnchor) {
      output = size + anchorSize + marginToAdd;
      if (offset2 + output + size > viewPortSize) {
        output = 0;
      }
    } else if (offset2 >= 0 && !isBeforeAnchor) {
      if (offset2 + size > viewPortSize) {
        output += -(anchorSize + size + marginToAdd);
      }
      if (offset2 + output < 0) {
        output = 0;
      }
    }
  }
  return output;
};
var restrictToView = function(options) {
  var anchorRect = options.anchorRect;
  var anchorAlign = options.anchorAlign;
  var elementRect = options.elementRect;
  var elementAlign = options.elementAlign;
  var collisions = options.collisions;
  var viewPort = options.viewPort;
  var margin = options.margin;
  if (margin === void 0)
    margin = {};
  var elementTop = elementRect.top;
  var elementLeft = elementRect.left;
  var elementHeight = elementRect.height;
  var elementWidth = elementRect.width;
  var viewPortHeight = viewPort.height;
  var viewPortWidth = viewPort.width;
  var horizontalMargin = margin.horizontal || 0;
  var verticalMargin = margin.vertical || 0;
  var left = 0;
  var top = 0;
  var isVerticalFit = collisions.vertical === collision_default.fit;
  var isHorizontalFit = collisions.horizontal === collision_default.fit;
  var isVerticalFlip = collisions.vertical === collision_default.flip;
  var isHorizontalFlip = collisions.horizontal === collision_default.flip;
  if (isVerticalFit) {
    top += fit(elementTop, elementHeight, viewPortHeight);
  }
  if (isHorizontalFit) {
    left += fit(elementLeft, elementWidth, viewPortWidth);
  }
  if (isVerticalFlip) {
    top += flip({
      margin: verticalMargin,
      offset: elementTop,
      size: elementHeight,
      anchorSize: anchorRect.height,
      viewPortSize: viewPortHeight,
      anchorAlignPoint: anchorAlign.vertical,
      elementAlignPoint: elementAlign.vertical
    });
  }
  if (isHorizontalFlip) {
    left += flip({
      margin: horizontalMargin,
      offset: elementLeft,
      size: elementWidth,
      anchorSize: anchorRect.width,
      viewPortSize: viewPortWidth,
      anchorAlignPoint: anchorAlign.horizontal,
      elementAlignPoint: elementAlign.horizontal
    });
  }
  var flippedVertical = isVerticalFlip && top !== 0;
  var flippedHorizontal = isHorizontalFlip && left !== 0;
  var fittedVertical = isVerticalFit && top !== 0;
  var fittedHorizontal = isHorizontalFit && left !== 0;
  return {
    flipped: flippedHorizontal || flippedVertical,
    fitted: fittedVertical || fittedHorizontal,
    flip: {
      horizontal: flippedHorizontal,
      vertical: flippedVertical
    },
    fit: {
      horizontal: fittedHorizontal,
      vertical: fittedVertical
    },
    offset: {
      left,
      top
    }
  };
};
var restrict_to_view_default = restrictToView;

// node_modules/@progress/kendo-popup-common/dist/es/siblings.js
function siblings_default(element) {
  var result = [];
  var sibling = element.parentNode.firstElementChild;
  while (sibling) {
    if (sibling !== element) {
      result.push(sibling);
    }
    sibling = sibling.nextElementSibling;
  }
  return result;
}

// node_modules/@progress/kendo-popup-common/dist/es/sibling-container.js
function sibling_container_default(anchor, container) {
  var parentElements = parents_default(anchor);
  var containerElement = container;
  var siblingElements;
  var result;
  while (containerElement) {
    siblingElements = siblings_default(containerElement);
    result = parentElements.reduce(function(list, p) {
      return list.concat(siblingElements.filter(function(s) {
        return s === p;
      }));
    }, [])[0];
    if (result) {
      break;
    }
    containerElement = containerElement.parentElement;
  }
  return result;
}

// node_modules/@progress/kendo-popup-common/dist/es/utils.js
function memoize(fun) {
  var result;
  var called = false;
  return function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    if (called) {
      return result;
    }
    result = fun.apply(void 0, args);
    called = true;
    return result;
  };
}
var hasRelativeStackingContext = memoize(function(elementSource) {
  if (!canUseDOM2()) {
    return false;
  }
  var currentDocument = elementSource ? elementSource.ownerDocument : document;
  if (!currentDocument || !currentDocument.body) {
    return false;
  }
  var top = 10;
  var parent = currentDocument.createElement("div");
  parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
  parent.innerHTML = '<div style="position: fixed; top: ' + top + 'px;">child</div>';
  currentDocument.body.appendChild(parent);
  var isDifferent = parent.children[0].getBoundingClientRect().top !== top;
  currentDocument.body.removeChild(parent);
  return isDifferent;
});
var canUseDOM2 = function() {
  return Boolean(typeof window !== "undefined" && window.document && window.document.createElement);
};

// node_modules/@progress/kendo-vue-popup/dist/es/util.js
var eitherRect = function eitherRect2(rect, offset2) {
  if (!rect) {
    return {
      height: 0,
      left: offset2.left,
      top: offset2.top,
      width: 0
    };
  }
  return rect;
};
var replaceOffset = function replaceOffset2(rect, offset2) {
  if (!offset2) {
    return rect;
  }
  var result = {
    height: rect.height,
    left: offset2.left,
    top: offset2.top,
    width: rect.width
  };
  return result;
};
var removeStackingOffset = function removeStackingOffset2(rect, stackingOffset) {
  if (!stackingOffset) {
    return rect;
  }
  var result = {
    height: rect.height,
    left: rect.left - stackingOffset.left,
    top: rect.top - stackingOffset.top,
    width: rect.width
  };
  return result;
};
var isDocumentAvailable = function isDocumentAvailable2() {
  return typeof document !== "undefined" && !!document.body;
};
var isWindowAvailable = function isWindowAvailable2() {
  return typeof window !== "undefined";
};
var OVERFLOW_REGEXP = /auto|scroll/;
var overflowStyle = function overflowStyle2(element) {
  var styles4 = window.getComputedStyle(element);
  return "" + styles4.overflow + styles4.overflowX + styles4.overflowY;
};
var scrollableParents = function scrollableParents2(element) {
  var parentElements = [];
  if (!isDocumentAvailable() || !isWindowAvailable()) {
    return parentElements;
  }
  var parent = element.parentElement;
  while (parent) {
    if (OVERFLOW_REGEXP.test(overflowStyle(parent))) {
      parentElements.push(parent);
    }
    parent = parent.parentElement;
  }
  parentElements.push(window);
  return parentElements;
};
var FRAME_DURATION = 1e3 / 60;
var hasRelativeStackingContext2 = function hasRelativeStackingContext3() {
  if (!isDocumentAvailable()) {
    return false;
  }
  var top = 10;
  var parent = document.createElement("div");
  parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
  parent.innerHTML = "<div>child</div>";
  document.body.appendChild(parent);
  if (parent && parent.firstChild) {
    var firstChild = parent.firstChild;
    firstChild.style.position = "fixed";
    firstChild.style.top = top + "px";
  }
  var isDifferent = parent.children[0].getBoundingClientRect().top !== top;
  document.body.removeChild(parent);
  return isDifferent;
};
var HAS_RELATIVE_STACKING_CONTEXT = hasRelativeStackingContext2();
var zIndex2 = function zIndex3(anchor, container) {
  if (!anchor || !isDocumentAvailable() || !isWindowAvailable()) {
    return null;
  }
  var sibling = sibling_container_default(anchor, container);
  if (!sibling) {
    return null;
  }
  var result = [anchor].concat(parents_default(anchor, sibling)).reduce(function(index, p) {
    var zIndexStyle = p.style.zIndex || window.getComputedStyle(p).zIndex;
    var current = parseInt(zIndexStyle, 10);
    return current > index ? current : index;
  }, 0);
  return result ? result + 1 : null;
};
var CollisionType = {
  fit: "fit",
  flip: "flip"
};
var AlignPoint = {
  left: "left",
  center: "center",
  right: "right",
  bottom: "bottom",
  top: "top"
};
var throttle = function throttle2(func, wait, options) {
  if (options === void 0) {
    options = {};
  }
  var timeout, context2, args, result;
  var previous = 0;
  options = options || {};
  var later = function later2() {
    previous = options.leading === false ? 0 : new Date().getTime();
    timeout = null;
    result = func.apply(context2, args);
    if (!timeout) {
      context2 = args = null;
    }
  };
  var throttled = function throttled2() {
    var now = new Date().getTime();
    if (!previous && options.leading === false) {
      previous = now;
    }
    var remaining = wait - (now - previous);
    context2 = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = func.apply(context2, args);
      if (!timeout) {
        context2 = args = null;
      }
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
  return throttled;
};

// node_modules/@progress/kendo-vue-popup/dist/es/services/alignService.js
var AlignService = function() {
  function AlignService2(_dom) {
    this._dom = _dom;
  }
  AlignService2.prototype.alignElement = function(settings) {
    var anchor = settings.anchor, element = settings.element, anchorAlign = settings.anchorAlign, elementAlign = settings.elementAlign, offset2 = settings.offset;
    var fixedMode = !this._dom.hasOffsetParent(element);
    var anchorRect = fixedMode ? this.absoluteRect(anchor, element, offset2) : this.relativeRect(anchor, element, offset2);
    return this._dom.align({
      anchorAlign,
      anchorRect,
      elementAlign,
      elementRect: this._dom.offset(element)
    });
  };
  AlignService2.prototype.absoluteRect = function(anchor, element, offset2) {
    var dom = this._dom;
    var rect = eitherRect(dom.offset(anchor), offset2);
    var stackingOffset = dom.stackingElementOffset(element);
    var removedOffset = removeStackingOffset(rect, stackingOffset);
    var stackingScroll = dom.stackingElementScroll(element);
    var withScroll = dom.addScroll(removedOffset, stackingScroll);
    var scrollPosition2 = this.elementScrollPosition(anchor, element);
    var result = dom.removeScroll(withScroll, scrollPosition2);
    result.left += window.scrollX || window.pageXOffset;
    result.top += window.scrollY || window.pageYOffset;
    return result;
  };
  AlignService2.prototype.elementScrollPosition = function(anchor, element) {
    return anchor ? { x: 0, y: 0 } : this._dom.scrollPosition(element);
  };
  AlignService2.prototype.relativeRect = function(anchor, element, offset2) {
    return eitherRect(this._dom.position(anchor, element), offset2);
  };
  return AlignService2;
}();

// node_modules/@progress/kendo-vue-popup/dist/es/services/domService.js
var DOMService = function() {
  function DOMService2() {
  }
  DOMService2.prototype.addOffset = function(current, addition) {
    return {
      left: current.left + addition.left,
      top: current.top + addition.top
    };
  };
  DOMService2.prototype.align = function(settings) {
    return align_default(settings);
  };
  DOMService2.prototype.boundingOffset = function(el) {
    return bounding_offset_default(el);
  };
  DOMService2.prototype.getWindow = function() {
    return isWindowAvailable() ? window : null;
  };
  DOMService2.prototype.isBodyOffset = function(el) {
    return is_body_offset_default(el);
  };
  DOMService2.prototype.hasOffsetParent = function(el) {
    if (!el) {
      return false;
    }
    var offsetParentEl = el.offsetParent;
    return offsetParentEl && !(offsetParentEl.nodeName === "BODY" && window.getComputedStyle(offsetParentEl).position === "static");
  };
  DOMService2.prototype.offset = function(el) {
    if (!el) {
      return null;
    }
    return offset_default(el);
  };
  DOMService2.prototype.staticOffset = function(element) {
    if (!element) {
      return null;
    }
    var _a = element.style, left = _a.left, top = _a.top;
    element.style.left = "0px";
    element.style.top = "0px";
    var currentOffset = offset_default(element);
    element.style.left = left;
    element.style.top = top;
    return currentOffset;
  };
  DOMService2.prototype.position = function(element, popup) {
    if (!element || !popup) {
      return null;
    }
    var parentSibling = sibling_container_default(element, popup);
    return position_with_scroll_default(element, parentSibling);
  };
  DOMService2.prototype.relativeOffset = function(el, currentLocation) {
    return applyLocationOffset(this.offset(el), currentLocation, this.isBodyOffset(el));
  };
  DOMService2.prototype.addScroll = function(rect, scroll) {
    return addScroll(rect, scroll);
  };
  DOMService2.prototype.removeScroll = function(rect, scroll) {
    return removeScroll(rect, scroll);
  };
  DOMService2.prototype.restrictToView = function(settings) {
    return restrict_to_view_default(settings);
  };
  DOMService2.prototype.scrollPosition = function(el) {
    return scrollPosition(el);
  };
  DOMService2.prototype.scrollableParents = function(el) {
    return scrollableParents(el);
  };
  DOMService2.prototype.stackingElementOffset = function(el) {
    var relativeContextElement = this.getRelativeContextElement(el);
    if (!relativeContextElement) {
      return null;
    }
    return offset_default(relativeContextElement);
  };
  DOMService2.prototype.stackingElementScroll = function(el) {
    var relativeContextElement = this.getRelativeContextElement(el);
    if (!relativeContextElement) {
      return { x: 0, y: 0 };
    }
    return {
      x: relativeContextElement.scrollLeft,
      y: relativeContextElement.scrollTop
    };
  };
  DOMService2.prototype.stackingElementViewPort = function(el) {
    var relativeContextElement = this.getRelativeContextElement(el);
    if (!relativeContextElement) {
      return null;
    }
    return {
      height: relativeContextElement.scrollHeight,
      width: relativeContextElement.scrollWidth
    };
  };
  DOMService2.prototype.getRelativeContextElement = function(el) {
    if (!el || !HAS_RELATIVE_STACKING_CONTEXT) {
      return null;
    }
    var parent = el.parentElement;
    while (parent) {
      if (window.getComputedStyle(parent).transform !== "none") {
        return parent;
      }
      parent = parent.parentElement;
    }
    return null;
  };
  DOMService2.prototype.useRelativePosition = function(el) {
    return !!this.getRelativeContextElement(el);
  };
  DOMService2.prototype.windowViewPort = function(el) {
    return windowViewport(el);
  };
  DOMService2.prototype.zIndex = function(anchor, container) {
    return zIndex2(anchor, container);
  };
  DOMService2.prototype.zoomLevel = function() {
    if (!isDocumentAvailable() || !isWindowAvailable()) {
      return 1;
    }
    return parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2));
  };
  DOMService2.prototype.isZoomed = function() {
    return this.zoomLevel() > 1;
  };
  return DOMService2;
}();

// node_modules/@progress/kendo-vue-popup/dist/es/services/positionService.js
var PositionService = function() {
  function PositionService2(_dom) {
    this._dom = _dom;
  }
  PositionService2.prototype.positionElement = function(settings) {
    var anchor = settings.anchor, currentLocation = settings.currentLocation, element = settings.element, anchorAlign = settings.anchorAlign, elementAlign = settings.elementAlign, collisions = settings.collisions;
    var dom = this._dom;
    var viewPort = settings.viewPort || dom.stackingElementViewPort(element) || dom.windowViewPort(element);
    var anchorRect = eitherRect(dom.offset(anchor), currentLocation);
    var initialElementRect = replaceOffset(dom.staticOffset(element), currentLocation);
    var elementRect = this.elementRect(element, initialElementRect);
    var result = dom.restrictToView({
      anchorAlign,
      anchorRect,
      collisions,
      elementAlign,
      elementRect,
      viewPort
    });
    return {
      flipped: result.flipped,
      offset: dom.addOffset(initialElementRect, result.offset)
    };
  };
  PositionService2.prototype.elementRect = function(element, rect) {
    return this._dom.removeScroll(rect, this._dom.scrollPosition(element));
  };
  return PositionService2;
}();

// node_modules/@progress/kendo-vue-popup/dist/es/package-metadata.js
var packageMetadata2 = {
  name: "@progress/kendo-vue-popup",
  productName: "Kendo UI for Vue",
  productCodes: ["KENDOUIVUE", "KENDOUICOMPLETE"],
  publishDate: 1656415189,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-vue-ui/my-license/?utm_medium=product&utm_source=kendovue&utm_campaign=kendo-ui-vue-purchase-license-keys-warning"
};

// node_modules/@progress/kendo-vue-popup/dist/es/Popup.js
var allVue11 = vue_runtime_esm_bundler_exports;
var gh11 = allVue11.h;
var DEFAULT_POPUP_ZINDEX = 100;
var ZINDEX_POPUP_STEP = 1;
var DEFAULT_OFFSET = {
  left: -1e3,
  top: 0
};
var ANIMATION_CONTAINER_SHOWN = "k-animation-container-shown";
var K_POPUP = "k-popup";
var PopupVue2 = {
  name: "Popup",
  props: {
    appendTo: {
      type: String,
      default: ""
    },
    anchor: {
      type: String,
      default: ""
    },
    className: String,
    id: String,
    popupClass: String,
    collision: {
      type: Object,
      default: function _default() {
        return {
          horizontal: CollisionType.fit,
          vertical: CollisionType.flip
        };
      }
    },
    anchorAlign: {
      type: Object,
      default: function _default2() {
        return {
          horizontal: AlignPoint.left,
          vertical: AlignPoint.bottom
        };
      }
    },
    popupAlign: {
      type: Object,
      default: function _default3() {
        return {
          horizontal: AlignPoint.left,
          vertical: AlignPoint.top
        };
      }
    },
    offset: {
      type: Object,
      default: function _default4() {
        return DEFAULT_OFFSET;
      }
    },
    show: {
      type: Boolean,
      default: false
    },
    animate: {
      type: [Boolean, Object],
      default: function _default5() {
        return true;
      }
    },
    direction: {
      type: String,
      default: "down"
    },
    transition: {
      type: String,
      default: "expand"
    }
  },
  inject: {
    kCurrentZIndex: {
      default: null
    }
  },
  data: function data() {
    return {
      hasMounted: false
    };
  },
  created: function created4() {
    validatePackage2(packageMetadata2);
    this.mountedAppendTo = void 0;
    this.mountedAnchor = void 0;
    this._initiallyMountedContent = void 0;
    this._flipped = false;
    this._offsetTop = 0;
    this._offsetLeft = -1e3;
    this._exitingAnimation = false;
    this._prevShow = false;
    this._prevShow = this.$props.show;
    this._domService = new DOMService();
    this._alignService = new AlignService(this._domService);
    this._positionService = new PositionService(this._domService);
    this.reposition = throttle(this.reposition.bind(this), FRAME_DURATION);
  },
  setup: !gh11 ? void 0 : function() {
    var v3 = !!gh11;
    return {
      v3
    };
  },
  mounted: function mounted3() {
    if (canUseDOM) {
      this.mountedAppendTo = this.$props.appendTo ? this.getParentRef(this.$props.appendTo) : document.body;
      this.mountedAnchor = this.$props.anchor ? this.getParentRef(this.$props.anchor) : document.body;
    }
    this._parentElement = this.$el.parentElement;
    this._initiallyMountedContent = this.$el.cloneNode(true);
    this.hasMounted = true;
    this.mountedAppendTo.appendChild(this.$el);
  },
  updated: function updated() {
    this._prevShow = this.$props.show;
  },
  destroyed: !!gh11 ? void 0 : function() {
    this.detachRepositionHandlers();
  },
  beforeDestroy: !!gh11 ? void 0 : function() {
    if (this._parentElement) {
      this._parentElement.appendChild(this.$el);
    }
  },
  unmounted: function unmounted2() {
    this.detachRepositionHandlers();
  },
  beforeUnmount: function beforeUnmount() {
    if (this._parentElement) {
      this._parentElement.appendChild(this.$el);
    }
  },
  methods: {
    onOpened: function onOpened() {
      var element = this.$el;
      if (this.$props.show) {
        element.classList.add(ANIMATION_CONTAINER_SHOWN);
      }
      this.attachRepositionHandlers(element);
      this.$emit("open", {
        target: this
      });
    },
    onClosing: function onClosing() {
      if (!this.$props.show) {
        var element = this.$el;
        element.classList.remove(ANIMATION_CONTAINER_SHOWN);
      }
      this.detachRepositionHandlers();
    },
    onClosed: function onClosed() {
      if (this._exitingAnimation) {
        this._exitingAnimation = false;
        this.$forceUpdate();
      }
      this.$emit("close", {
        target: this
      });
    },
    transitionDuration: function transitionDuration() {
      var animate2 = this.$props.animate;
      var transitionEnterDuration = 0;
      var transitionExitDuration = 0;
      if (animate2) {
        if (animate2 === true) {
          transitionEnterDuration = transitionExitDuration = void 0;
        } else {
          transitionEnterDuration = animate2.openDuration;
          transitionExitDuration = animate2.closeDuration;
        }
      }
      return {
        transitionEnterDuration,
        transitionExitDuration
      };
    },
    getParentRef: function getParentRef(anchor) {
      var parent = this.$parent;
      while (!parent.$refs[anchor]) {
        if (parent && parent.kendoAnchorRef) {
          return parent.kendoAnchorRef;
        }
        parent = parent.$parent;
        if (!parent && canUseDOM) {
          return document.body;
        }
      }
      return parent.$refs[anchor].$el || parent.$refs[anchor];
    },
    position: function position2(settings, element, anchor) {
      var anchorAlign = settings.anchorAlign, popupAlign = settings.popupAlign, collision = settings.collision, offset2 = settings.offset;
      var anchorElement = anchor ? this.v3 ? this.mountedAnchor : this.getParentRef(anchor) : document.body;
      var alignedOffset = this._alignService.alignElement({
        anchor: anchor ? anchorElement : void 0,
        element,
        elementAlign: popupAlign,
        anchorAlign,
        offset: offset2
      });
      var result = this._positionService.positionElement({
        anchor: anchorElement,
        anchorAlign,
        collisions: collision,
        element,
        currentLocation: alignedOffset,
        elementAlign: popupAlign
      });
      return result;
    },
    calculatePosition: function calculatePosition($props, appendToElement) {
      if (!appendToElement || !isWindowAvailable() || !canUseDOM) {
        return {
          flipped: false,
          offset: $props.offset
        };
      }
      var defaultSlot = getDefaultSlots(this);
      var root = document.createElement("div");
      var contentElement = this.$el && this.$el.firstChild ? this.$el.firstChild.firstChild ? this.$el.firstChild.firstChild.cloneNode(true) : null : null;
      var divWrapper = contentElement && contentElement.getBoundingClientRect ? contentElement : this._initiallyMountedContent;
      if (divWrapper) {
        root.appendChild(divWrapper);
      } else {
        var internalClass = this.v3 ? defaultSlot && defaultSlot[0].props ? defaultSlot[0].props.class : "" : defaultSlot && defaultSlot[0].data ? defaultSlot[0].data.staticClass : "";
        var domClass = this.v3 ? this.$props.popupClass ? this.$props.popupClass : "" : defaultSlot && defaultSlot[0].data ? defaultSlot[0].data.class : "";
        root.innerHTML = '<div class="k-animation-container k-animation-container-relative">	\n                        <div class="k-popup k-animation-container k-animation-container-relative">\n                            <div class="' + internalClass + " " + domClass + '" >\n                            </div>	\n                        </div>	\n                </div>';
      }
      appendToElement.appendChild(root);
      if (root && root.firstChild) {
        var firstChild = root.firstChild;
        firstChild.style.position = "absolute";
        firstChild.style.visibility = "hidden";
        firstChild.style.display = "block";
        firstChild.style.left = "-1000";
        firstChild.style.top = "0";
        var inlineStyles = this.v3 ? defaultSlot && defaultSlot[0].props ? defaultSlot[0].props.style : {} : defaultSlot[0].data ? defaultSlot[0].data.style : {};
        if (inlineStyles) {
          for (var _i = 0, _a = Object.entries(inlineStyles); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            firstChild.style[key] = value;
          }
        }
      }
      var newPosition = this.position($props, root.firstChild, this.$props.anchor);
      root.parentNode.removeChild(root);
      return newPosition;
    },
    attachRepositionHandlers: function attachRepositionHandlers(element) {
      var _this = this;
      this.detachRepositionHandlers();
      this._scrollableParents = this._domService.scrollableParents(this.$props.anchor ? this.mountedAnchor : element);
      this._scrollableParents.map(function(p) {
        return p.addEventListener("scroll", _this.reposition);
      });
      window.addEventListener("resize", this.reposition);
    },
    detachRepositionHandlers: function detachRepositionHandlers() {
      var _this = this;
      if (this._scrollableParents) {
        this._scrollableParents.map(function(p) {
          return p.removeEventListener("scroll", _this.reposition);
        });
        this._scrollableParents = void 0;
      }
      window.removeEventListener("resize", this.reposition);
    },
    reposition: function reposition() {
      this.$forceUpdate();
    },
    getCurrentZIndex: function getCurrentZIndex() {
      return this.kCurrentZIndex ? this.kCurrentZIndex + ZINDEX_POPUP_STEP : DEFAULT_POPUP_ZINDEX;
    }
  },
  render: function render5(createElement) {
    var h = gh11 || createElement;
    var _a = this.$props, className = _a.className, popupClass = _a.popupClass, show = _a.show, id = _a.id;
    var defaultSlots = getDefaultSlots(this);
    var defaultSlot = this.v3 ? defaultSlots : show ? defaultSlots : null;
    var defaultAppentTo = isWindowAvailable() ? this.$props.appendTo ? this.mountedAppendTo || this.getParentRef(this.$props.appendTo) : document.body : void 0;
    if (this.$props.show) {
      var newPosition = this.calculatePosition(this.$props, defaultAppentTo);
      this._offsetLeft = newPosition.offset.left;
      this._offsetTop = newPosition.offset.top;
      this._flipped = !!newPosition.flipped;
    }
    var direction = this._flipped ? "up" : "down";
    var _b = this.transitionDuration(), transitionEnterDuration = _b.transitionEnterDuration, transitionExitDuration = _b.transitionExitDuration;
    var currentZIndex = this.getCurrentZIndex();
    this._exitingAnimation = this._exitingAnimation || this._prevShow && !show;
    if (!this.hasMounted) {
      return h("div", {
        style: {
          display: "none"
        },
        "class": className
      }, [h("div", {
        "class": [popupClass, K_POPUP]
      }, [defaultSlots])]);
    }
    if (show || this._exitingAnimation && defaultAppentTo) {
      var popup = h(Slide, {
        id,
        attrs: this.v3 ? void 0 : {
          id,
          componentChildClassName: [popupClass, K_POPUP],
          className,
          direction,
          transitionEnterDuration,
          transitionExitDuration,
          appear: show
        },
        componentChildClassName: [popupClass, K_POPUP],
        className,
        onEntered: this.onOpened,
        on: this.v3 ? void 0 : {
          "entered": this.onOpened,
          "exiting": this.onClosing,
          "exited": this.onClosed
        },
        onExiting: this.onClosing,
        onExited: this.onClosed,
        direction,
        style: {
          zIndex: currentZIndex,
          position: "absolute",
          top: this._offsetTop + "px",
          left: this._offsetLeft + "px"
        },
        transitionEnterDuration,
        transitionExitDuration,
        appear: show
      }, this.v3 ? function() {
        return [defaultSlot];
      } : [defaultSlot]);
      return popup;
    }
    return null;
  }
};
var Popup = PopupVue2;

export {
  classNames,
  guid,
  Keys,
  canUseDOM,
  focusFirstFocusableChild,
  main_default,
  getDefaultSlots,
  Draggable3 as Draggable,
  noop2 as noop,
  getListeners,
  templateRendering,
  getTemplate,
  getTabIndex,
  isRtl,
  getDir,
  validatePackage,
  index_esm_exports,
  validatePackage2,
  kendoThemeMaps,
  PopupVue2,
  Popup
};
//# sourceMappingURL=chunk-LTSFIFKS.js.map
