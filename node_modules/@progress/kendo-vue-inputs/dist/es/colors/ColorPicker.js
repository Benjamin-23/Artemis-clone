// @ts-ignore
import * as Vue from 'vue';
var allVue = Vue;
var gh = allVue.h;
var isV3 = allVue.version[0] === '3';
import { Button } from '@progress/kendo-vue-buttons';
import { classNames, Keys, // useDir, 
getTabIndex, guid, kendoThemeMaps, validatePackage } from '@progress/kendo-vue-common';
import { packageMetadata } from '../package-metadata';
import { Picker } from './Picker';
import { ColorPalette, DEFAULT_PRESET, DEFAULT_TILE_SIZE } from './ColorPalette';
/**
 * @hidden
 */

var DEFAULT_GRADIENT_SETTINGS = {
  opacity: true
};
/**
 * @hidden
 */

var DEFAULT_PALETTE_SETTINGS = {
  palette: DEFAULT_PRESET,
  tileSize: DEFAULT_TILE_SIZE
};
/**
 * @hidden
 */

var isControlled = function isControlled(prop) {
  return prop !== undefined;
};
/**
 * @hidden
 */


var ColorPickerVue2 = {
  name: 'KendoColorPicker',
  props: {
    value: {
      type: String,
      default: undefined
    },
    defaultValue: String,
    disabled: Boolean,
    dir: String,
    id: String,
    ariaLabelledBy: String,
    ariaDescribedBy: String,
    paletteSettings: {
      type: Object,
      default: function _default() {
        return DEFAULT_PALETTE_SETTINGS;
      }
    },
    valid: {
      type: Boolean,
      default: true
    },
    tabIndex: {
      type: Number,
      default: 0
    },
    title: String,
    icon: String,
    iconClassName: String,
    popupSettings: Object,
    open: {
      type: Boolean,
      default: undefined
    },
    size: {
      type: String,
      default: 'medium',
      validator: function validator(value) {
        return [null, 'small', 'medium', 'large'].includes(value);
      }
    },
    rounded: {
      type: String,
      default: 'medium',
      validator: function validator(value) {
        return [null, 'small', 'medium', 'large', 'full'].includes(value);
      }
    },
    fillMode: {
      type: String,
      default: 'solid',
      validator: function validator(value) {
        return [null, 'solid', 'flat', 'outline'].includes(value);
      }
    }
  },
  data: function data() {
    return {
      focused: false,
      stateValue: '',
      stateOpen: false
    };
  },
  computed: {
    isValueControlled: function isValueControlled() {
      return isControlled(this.$props.value);
    },
    isOpenControlled: function isOpenControlled() {
      return isControlled(this.$props.open);
    },
    computedValue: function computedValue() {
      return this.isValueControlled ? this.$props.value : this.stateValue;
    },
    computedOpen: function computedOpen() {
      return this.isOpenControlled ? this.$props.open : this.stateOpen;
    },
    computedIconClassName: function computedIconClassName() {
      var icon = this.$props.icon;
      return this.$props.iconClassName || icon && "k-icon k-i-" + icon;
    },
    wrapperClassName: function wrapperClassName() {
      var _a;

      var _b = this.$props,
          size = _b.size,
          fillMode = _b.fillMode,
          rounded = _b.rounded;
      return _a = {
        'k-picker': true,
        'k-colorpicker': true
      }, _a["k-picker-" + (kendoThemeMaps.sizeMap[size] || size)] = size, _a["k-picker-" + fillMode] = fillMode, _a["k-rounded-" + (kendoThemeMaps.roundedMap[rounded] || rounded)] = rounded, _a['k-invalid'] = !this.valid, _a['k-disabled'] = this.disabled, _a['k-focus'] = this.focused, _a;
    }
  },
  created: function created() {
    validatePackage(packageMetadata);
    this.focusableElementGuid = guid();
  },
  mounted: function mounted() {
    this.focusableElement = this.$refs[this.focusableElementGuid];
    this.button = this.v3 ? this.buttonRef : this.$refs.button;
    this.palette = this.v3 ? this.paletteRef : this.$refs.palette;
  },
  updated: function updated() {
    this.button = this.v3 ? this.buttonRef : this.$refs.button;
    this.palette = this.v3 ? this.paletteRef : this.$refs.palette;
  },
  // @ts-ignore
  setup: !isV3 ? undefined : function () {
    var v3 = !!isV3;
    return {
      v3: v3
    };
  },
  // @ts-ignore
  render: function render(createElement) {
    var _this2 = this;

    var _a;

    var _this = this;

    var h = gh || createElement;
    var _b = this.$props,
        disabled = _b.disabled,
        tabIndex = _b.tabIndex,
        dir = _b.dir; // const dir = useDir(focusableElementGuid, props.dir);

    return h("span", {
      "class": this.wrapperClassName,
      dir: dir,
      attrs: this.v3 ? undefined : {
        dir: dir,
        id: this.$props.id,
        "aria-labelledby": this.$props.ariaLabelledBy,
        "aria-describedby": this.$props.ariaDescribedBy,
        tabindex: getTabIndex(tabIndex, disabled),
        title: this.$props.title
      },
      id: this.$props.id,
      "aria-labelledby": this.$props.ariaLabelledBy,
      "aria-describedby": this.$props.ariaDescribedBy,
      ref: this.focusableElementGuid,
      tabindex: getTabIndex(tabIndex, disabled),
      title: this.$props.title,
      onKeydown: this.onKeyDownHandler,
      on: this.v3 ? undefined : {
        "keydown": this.onKeyDownHandler,
        "focusin": this.onFocusHandler,
        "focusout": this.onBlurHandler
      },
      onFocusin: this.onFocusHandler,
      onFocusout: this.onBlurHandler
    }, [h("span", {
      onClick: this.onActiveColorClickHandler,
      on: this.v3 ? undefined : {
        "click": this.onActiveColorClickHandler
      },
      "class": 'k-input-inner'
    }, [h("span", {
      "class": classNames('k-value-icon', 'k-color-preview', {
        'k-no-color': !this.computedValue,
        'k-icon-color-preview': this.icon || this.iconClassName
      })
    }, [(this.iconClassName || this.icon) && h("span", {
      "class": classNames('k-color-preview-icon', this.iconClassName, (_a = {}, _a["k-icon k-i-" + this.icon] = this.icon && !this.iconClassName, _a))
    }), h("span", {
      "class": "k-color-preview-mask",
      style: {
        backgroundColor: this.computedValue
      }
    })])]), // @ts-ignore
    h(Button, {
      type: "button",
      attrs: this.v3 ? undefined : {
        type: "button",
        rounded: null,
        icon: 'arrow-s'
      },
      ref: this.v3 ? function (el) {
        _this.buttonRef = el;
      } : 'button',
      onClick: this.onClickHandler,
      on: this.v3 ? undefined : {
        "click": this.onClickHandler
      },
      rounded: null,
      "class": "k-input-button",
      icon: 'arrow-s'
    }), // @ts-ignore function children
    h(Picker, {
      dir: dir,
      attrs: this.v3 ? undefined : {
        dir: dir,
        open: this.computedOpen,
        popupAnchor: this.focusableElementGuid
      },
      open: this.computedOpen,
      onOpen: this.onOpenHandler,
      on: this.v3 ? undefined : {
        "open": this.onOpenHandler
      },
      popupAnchor: this.focusableElementGuid
    }, this.v3 ? function () {
      return [// @ts-ignore function children
      h(ColorPalette, {
        onKeydown: _this2.onKeyDownHandler //      {...paletteSettings}
        ,
        on: _this2.v3 ? undefined : {
          "keydown": _this2.onKeyDownHandler,
          "change": _this2.onPaletteChangeHandler,
          "blur": _this2.onBlurHandler
        },
        ref: _this2.v3 ? function (el) {
          _this.paletteRef = el;
        } : 'palette',
        value: _this2.computedValue || undefined,
        attrs: _this2.v3 ? undefined : {
          value: _this2.computedValue || undefined
        },
        onChange: _this2.onPaletteChangeHandler,
        onBlur: _this2.onBlurHandler
      })];
    } : [h(ColorPalette, {
      onKeydown: _this2.onKeyDownHandler,
      on: _this2.v3 ? undefined : {
        "keydown": _this2.onKeyDownHandler,
        "change": _this2.onPaletteChangeHandler,
        "blur": _this2.onBlurHandler
      },
      ref: _this2.v3 ? function (el) {
        _this.paletteRef = el;
      } : 'palette',
      value: _this2.computedValue || undefined,
      attrs: _this2.v3 ? undefined : {
        value: _this2.computedValue || undefined
      },
      onChange: _this2.onPaletteChangeHandler,
      onBlur: _this2.onBlurHandler
    })])]);
  },
  methods: {
    focusElement: function focusElement() {
      if (this.focusableElement) {
        this.focusableElement.focus();
      }
    },
    setOpen: function setOpen(nextOpen, isBlur) {
      if (!this.isOpenControlled) {
        if (!nextOpen && !isBlur && this.focusableElement) {
          this.focusableElement.focus();
        }

        this.stateOpen = nextOpen;
      }
    },
    onKeyDownHandler: function onKeyDownHandler(event) {
      var altKey = event.altKey,
          keyCode = event.keyCode;

      if (keyCode === Keys.esc) {
        this.setOpen(false);
        return;
      }

      if (keyCode === Keys.enter && !this.isOpenControlled) {
        event.preventDefault();
        event.stopPropagation();
        this.setOpen(!this.computedOpen);
        return;
      }

      if (altKey && (keyCode === Keys.up || keyCode === Keys.down)) {
        event.preventDefault();
        event.stopPropagation();

        if (keyCode === Keys.up && this.focusableElement) {
          this.focusableElement.focus();
          this.setOpen(false);
        }

        if (keyCode === Keys.down) {
          this.setOpen(true);
        }
      }
    },
    onOpenHandler: function onOpenHandler() {
      // Skip content autofocus when in controlled mode
      if (!this.isOpenControlled) {
        if (this.palette) {
          this.palette.focus();
        }
      }
    },
    onClickHandler: function onClickHandler() {
      this.setOpen(!this.computedOpen, true);
    },
    onActiveColorClickHandler: function onActiveColorClickHandler(event) {
      this.$emit('activecolorclick', {
        event: event,
        value: this.computedValue
      });
    },
    onFocusHandler: function onFocusHandler(event) {
      if (this.blurTimeoutRef) {
        clearTimeout(this.blurTimeoutRef);
        this.blurTimeoutRef = undefined; // case where moving back to input from popup
        // if (event.target === this.focusableElement) {
        //     this.setOpen(false); // in this case we should focus input on keydown
        // }
      } else {
        this.focused = true;
      }

      this.$emit('focus', {
        event: event
      });
    },
    onBlurTimeout: function onBlurTimeout() {
      var paleteIsFocused = this.palette && document.activeElement === this.palette.$el;

      if (!paleteIsFocused) {
        this.setOpen(false, true);
      }

      this.focused = paleteIsFocused;
      this.blurTimeoutRef = undefined;
    },
    onBlurHandler: function onBlurHandler(event) {
      clearTimeout(this.blurTimeoutRef);
      this.blurTimeoutRef = window.setTimeout(this.onBlurTimeout, 200);
      this.$emit('blur', {
        event: event
      });
    },
    onChangeHandler: function onChangeHandler(event, isPalette) {
      var currentValue = isPalette ? event.rgbaValue : event.value;

      if (!this.isValueControlled) {
        this.stateValue = currentValue;
      }

      if (isPalette) {
        this.setOpen(false);
      }

      this.$emit('change', {
        value: currentValue,
        event: event
      });
    },
    onPaletteChangeHandler: function onPaletteChangeHandler(event) {
      this.onChangeHandler(event, true);
    }
  }
};
/**
 * @hidden
 */

var ColorPicker = ColorPickerVue2;
export { ColorPicker, ColorPickerVue2 };